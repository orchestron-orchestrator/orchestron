import logging
import yang.adata
import yang.gdata as gdata
import orchestron.device as odev
import orchestron.ttt
from orchestron import UnsupportedDevice

import mini.layers.base_1 as base
from mini.layers.y_1 import orchestron_rfs__rfs__bar__dynstate as BarDynstate
import mini.layers.y_1 as y1

import mini.devices.ietf as ietf_dev
from mini.devices.ietf import root as ietf_root

NS_IETF_SYSTEM = "urn:ietf:params:xml:ns:yang:ietf-system"

def _q_sys(name: str) -> gdata.Id:
    return gdata.Id(NS_IETF_SYSTEM, name)

def _ms_to_ns(ms: u64) -> u64:
    return ms * 1000 * 1000



class BaseConfig(base.BaseConfig):
    def transform(self, i, di):
        print("RFS /rfs{{{di.name}}}/base-config transform running", err=True)

        if "ietf-system" in di.modules:
            dev = ietf_dev.root()
            dev.system.hostname = i.name

            return dev

        raise UnsupportedDevice()


class Bar(base.Bar):
    def transform(self, i, di, dynstate: ?BarDynstate):
        print("RFS /rfs{{{di.name}}}/bar transform running", err=True)

        if "ietf-system" in di.modules:
            dev = ietf_dev.root()
            d = dev.system.dns_resolver.server.create(i.name)
            if dynstate is not None:
                dev.system.contact = dynstate.current_datetime

            return dev

        raise UnsupportedDevice()


actor BarTransform(update_dynstate: proc(?BarDynstate)->None, dev: odev.DeviceMgr):
    var handle: ?odev.SubscriptionHandle = None
    # TODO: bah, ietf tree has some mandatory config false leafs at the root under NACM
    var tree = ietf_root()
    tree.nacm.denied_operations = 0
    tree.nacm.denied_data_writes = 0
    tree.nacm.denied_notifications = 0
    var gtree = tree.to_gdata()

    def on_update(n: ?gdata.Node, err: ?Exception):
        if err is not None:
            print("BarTransform subscription error: {err}", err=True)
            return
        if n is not None:
            gtree2 = gdata.patch(gtree, n)
            if gtree2 is not None:
                gtree = gtree2
            t = ietf_root.from_gdata(gtree)
            if t is not None:
                tss = t.system_state
                if tss is not None:
                    clock = tss.clock
                    if clock is not None:
                        update_dynstate(BarDynstate(clock.current_datetime))


    def on_conf(conf: y1.orchestron_rfs__rfs__bar_entry):
        if handle is not None:
            return
        opts = odev.SubscriptionOpts(odev.SUB_PERIODIC, period=_ms_to_ns(u64(10)))
        handle = dev.subscribe(on_update, _system_state_filter(), opts)

def _system_state_filter() -> gdata.FNode:
    return gdata.FNode(None, None, [
        gdata.FNode(_q_sys("system-state"), children=[])
    ])
