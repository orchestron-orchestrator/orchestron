import testing

import yang.gdata as gdata
import orchestron.device as odev
import orchestron.ttt as ttt

import mini.layers.t_1
import mini.sysspec

from orchestron.device_meta_config import \
    orchestron_rfs__device_entry as DeviceMetaConfig, \
    orchestron_rfs__device__credentials as Credentials, \
    orchestron_rfs__device__mock as Mock, \
    orchestron_rfs__device__mock__module_entry as MockModule

NS_ORFS = "http://orchestron.org/yang/orchestron-rfs.yang"
NS_DEV = "http://orchestron.org/yang/orchestron-device.yang"
NS_MINI_RFS = "http://example.com/mini-rfs"
NS_IETF_SYSTEM = "urn:ietf:params:xml:ns:yang:ietf-system"
IETF_SYSTEM_MODULE = "ietf-system"


def q_orfs(n: str) -> gdata.Id:
    return gdata.Id(NS_ORFS, n)


def q_mrfs(n: str) -> gdata.Id:
    return gdata.Id(NS_MINI_RFS, n)


def q_sys(n: str) -> gdata.Id:
    return gdata.Id(NS_IETF_SYSTEM, n)


def q_dev(n: str) -> gdata.Id:
    return gdata.Id(NS_DEV, n)


def _rfs_for_device(dev: str) -> gdata.Node:
    return gdata.Container({
        q_orfs("rfs"): gdata.List([q_orfs("name")], [
            gdata.Container({
                q_orfs("name"): gdata.Leaf(dev),
                q_mrfs("bar"): gdata.List([q_mrfs("name")], [
                    gdata.Container({
                        q_mrfs("name"): gdata.Leaf("default"),
                    })
                ])
            })
        ])
    })


def _telemetry(current_datetime: str) -> gdata.Node:
    return gdata.Container({
        q_sys("system-state"): gdata.Container({
            q_sys("clock"): gdata.Container({
                q_sys("current-datetime"): gdata.Leaf(current_datetime, ns=NS_IETF_SYSTEM, module=IETF_SYSTEM_MODULE)
            }, ns=NS_IETF_SYSTEM, module=IETF_SYSTEM_MODULE)
        }, ns=NS_IETF_SYSTEM, module=IETF_SYSTEM_MODULE)
    })


def _find_contact(root: gdata.Node, dev_name: str) -> ?str:
    if not isinstance(root, gdata.Container):
        return None
    devs = root.children.get(q_dev("devices"))
    if isinstance(devs, gdata.Container):
        dev_list = devs.children.get(q_dev("device"))
        if isinstance(dev_list, gdata.List):
            for elem in dev_list.elements:
                if not isinstance(elem, gdata.Container):
                    continue
                name_leaf = elem.children.get(q_dev("name"))
                if isinstance(name_leaf, gdata.Leaf):
                    nval = name_leaf.val
                    if isinstance(nval, str) and nval == dev_name:
                        conf = elem.children.get(q_dev("config"))
                        if isinstance(conf, gdata.Container):
                            sys = conf.children.get(q_sys("system"))
                            if isinstance(sys, gdata.Container):
                                contact = sys.children.get(q_sys("contact"))
                                if isinstance(contact, gdata.Leaf):
                                    val = contact.val
                                    if isinstance(val, str):
                                        return val
    return None


actor _test_rfs_subscribe_transform(t: testing.AsyncT):
    """RFS transform actor subscription (periodic NETCONF mock).

    1. Create DeviceMgr in NETCONF mock-server mode with IETF system schema.
    2. Side-load operational datastore on the mock NETCONF server.
    3. Apply RFS config to create a bar entry and start the transform actor.
    4. Verify system.contact updates on successive periodic subscription polls.
    """
    dev_registry = odev.DeviceRegistry(mini.sysspec.device_types, None, t.log_handler)
    dev = dev_registry.get("dev1")
    # TODO: hmm, we should not do this, right? it'll conflict with DMC from TTT
    dev.set_dmc(DeviceMetaConfig("dev1", Credentials("", None), type="ietf", mock=Mock(module=[
        MockModule("ietf-system", NS_IETF_SYSTEM, None)
    ])))

    sink = ttt.Sink()
    rfs = ttt.Layer("rfs", mini.layers.t_1.get_ttt(sink, dev_registry, t.log_handler), sink)

    telemetry_time_1 = "2026-02-08T12:34:56Z"
    telemetry_time_2 = "2026-02-08T12:34:57Z"

    var done = False
    var phase = 0
    var attempts = 0
    var mock_server: ?odev.NetconfMockServer = None

    def fail(msg: str):
        if done:
            return
        done = True
        t.failure(ValueError(msg))

    def poll():
        if done:
            return
        attempts += 1
        out = sink.get()
        contact = _find_contact(out, "dev1")
        if phase == 0 and contact == telemetry_time_1:
            phase = 1
            ms = gdata.expect(mock_server, "mock server")
            ms.set_oper_ds(_telemetry(telemetry_time_2))
            print("Received first telemetry update with contact:", contact)
        elif phase == 1 and contact == telemetry_time_2:
            done = True
            t.success()
            return

        if attempts >= 20:
            if contact is None:
                fail("Timed out waiting for system.contact update")
            else:
                fail("Unexpected system.contact value: {contact}")
            return

        after 0.01: poll()

    def on_config(_r: value):
        after 0: poll()

    def kick():
        modset, modset_id = dev.get_modules()
        if modset_id is None:
            after 0: kick()
            return
        rfs.edit_config(_rfs_for_device("dev1"), on_config, None, True)

    def start():
        msg = async dev.get_adapter()
        adapter = await msg
        if isinstance(adapter, odev.NetconfAdapter):
            ms = gdata.expect(adapter.get_mock_server(), "Netconf mock server")
            mock_server = ms
            ms.set_oper_ds(_telemetry(telemetry_time_1))
            kick()
        else:
            fail("Expected NetconfAdapter from DeviceMgr")

    after 0: start()
