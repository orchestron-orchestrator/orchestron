import yang.adata
import yang.gdata as gdata
import orchestron.device as odev
from orchestron.device_meta_config import orchestron_rfs__device_entry as DeviceMetaConfig
import xml, logging

def per_src(cfg_per_src: dict[str, gdata.Node]):
    return "\n".join([f"        '{src}': {cfg.prsrc(True, 4, src)}" for src,cfg in cfg_per_src.items()])

WILDKEY = ""

def transpose(cfg_per_src: dict[str, gdata.Node]) -> dict[str, dict[str, gdata.Node]]:
    cfg_per_key = {}
    for src, conf in cfg_per_src.items():
        if isinstance(conf, gdata.List):
            for le in conf.elements:
                key = le.key_str(conf.keys)
                if key in cfg_per_key:
                    cfg_per_key[key][src] = le
                else:
                    cfg_per_key[key] = {src: le}
        elif isinstance(conf, gdata.Container):
            for key, subconf in conf.children.items():
                if key in cfg_per_key:
                    cfg_per_key[key][src] = subconf
                else:
                    cfg_per_key[key] = {src: subconf}
        elif isinstance (conf, gdata.Absent):
            cfg_per_key[WILDKEY] = {src: conf}
        else:
            raise NotImplementedError(f"Cannot transpose configuration type{type(conf)}")

    return cfg_per_key

def difference(a: ?gdata.Node, b: gdata.Node) -> ?gdata.Node:
    if a is not None:
        return gdata.diff(a, b)
    else:
        return b

def patch(conf: dict[str,gdata.Node], diff: dict[str,gdata.Node]) -> dict[str,gdata.Node]:
    res = {}
    for s,d in diff.items():
        if s in conf:
            p = gdata.patch(conf[s], d)
            if p is not None:
                res[s] = p
        elif not isinstance(d, gdata.Absent):
            res[s] = d
    for s,c in conf.items():
        if s not in diff:
            res[s] = c
    return res

def assert_complete(conf: gdata.Node):
    return conf

def merge(cfg_per_src: dict[str,gdata.Node]):
    acc = None
    for conf in cfg_per_src.values():
        if acc is not None:
            acc = gdata.merge(acc, conf)
        else:
            acc = conf
    if acc is not None:
        return acc
    else:
        raise ValueError("Nothing to merge")

def split_key_str(key_str: str) -> list[str]:
    """
    Split a comma-separated string into individual components,
    respecting escaped commas (\\,).
    """
    result = []
    current = ""
    i = 0

    while i < len(key_str):
        if key_str[i] == '\\' and i + 1 < len(key_str) and key_str[i + 1] == ',':
            current += ','
            i += 2
        elif key_str[i] == ',':
            result.append(current)
            current = ""
            i += 1
        else:
            current += key_str[i]
            i += 1

    # Last, or only element
    if current != "" or i > 0:
        result.append(current)

    return result

def expect[T](t: ?T, errmsg: str) -> T:
    if t is not None:
        return t
    raise ValueError(errmsg)

##################### Database stub ###########################

actor Db():
    def put(path: list[str], data: gdata.Node):
        pass

##################### Node & Transactions #####################

class YieldState(object):
    it: Iterator[str]
    key: str
    tid: str
    out: ?Session
    results: dict[str,value]
    @property
    done: action(value) -> None

    def __init__(self, it, key, tid, out, done):
        self.it = it
        self.key = key
        self.tid = tid
        self.out = out
        self.results = {}
        self.done = done


actor Node(impl: _Node):
    def newtrans():
        return impl.newtrans()

    def get():
        return impl.get()

class _Node(object):
    path: list[str]
    newtrans: proc() -> Transaction
    get: proc() -> gdata.Node


actor Transaction(impl: _Transaction):
    def configure(tid, diff, out, force=False):
        return impl.configure(tid, diff, out, force)

    # yield action
    def lock(tid, out, done):
        impl.lock(self, tid, out, done)

    def lock_cont(res):
        impl.lock_cont(self, res)

    def commit(tid, ok, db):
        impl.commit(tid, ok, db)

    def wait_complete(tid, done):
        impl.wait_complete(self, tid, done)

    def wait_complete_cont(res):
        impl.wait_complete_cont(self, res)

    def get():
        return impl.get()

    def init_dynstate(node: Node, act: proc(TransformActorParams) -> ?proc(gdata.Node, ?gdata.Node) -> None):
        impl.init_dynstate(node, act, update_dynstate)

    def update_dynstate(dynstate: ?yang.adata.MNode):
        impl.update_dynstate(dynstate.to_gdata() if dynstate is not None else None)

class _Transaction(object):
    path: list[str]
    configure:  proc(tid: str, diff: dict[str,gdata.Node], out: ?Session, force: ?bool) -> value
    # yield action
    lock : proc(actself: Transaction, tid: str, out: ?Session, done: action(value) -> None) -> None
    lock_cont : proc(actself: Transaction, res: value) -> None
    commit: proc(tid: str, ok: bool, db: ?Db) -> None
    wait_complete: proc(actself: Transaction, tid: str, done: action(value) -> None) -> None
    wait_complete_cont : proc(actself: Transaction, res: value) -> None
    get: proc() -> gdata.Node

    proc def init_dynstate(self, node: Node, act: proc(TransformActorParams) -> ?proc(gdata.Node, ?gdata.Node) -> None, update_dynstate: proc(?yang.adata.MNode)->None):
        pass

    proc def update_dynstate(self, dynstate: ?gdata.Node) -> None:
        pass

####################### Layer ########################

actor Layer(name: str, rootgen: proc(list[str], ?Layer)->Node, lower: ?Layer, db: ?Db):
    root = rootgen([f"({name})"], lower)

    def newsession():
        return Session(name, root, lower, db)

    def below():
        return lower if lower is not None else self

    def edit_config(diff, done=None, complete=None, force=False):
        newsession().edit_config(diff, done, complete, force)

    def get():
        return root.get()


actor Session(name: str, rootnode: Node, lowerlayer: ?Layer, db: ?Db):
    root: Transaction = rootnode.newtrans()
    lower: ?Session = lowerlayer.newsession() if lowerlayer is not None else None
    
    var buf: dict[str,gdata.Node] = {}
    var lock_cont: ?action(value)->None = None
    var done_cont: ?action(value)->None = None
    var comp_cont: ?action(value)->None = None
    var tid_state = None

    # yield action
    def edit_config(diff, done: ?action(value)->None=None, complete: ?action(value)->None=None, force=False):
        tid = 'tr' + actorid()
        #print('####', tid, '(Layer)', name, 'edit_config', actorid(), err=True)
        configure(tid, {'_': diff})
        res = apply(tid, force)
        #print('   #', tid, '(Layer)', name, 'EDIT_CONFIG', 'PREP RESULT', res, err=True)
        if isinstance(res, str) and res == 'Ok':
            done_cont = done
            comp_cont = complete
            lock(tid, edit_config_cont)                                     # yield await
        else:
            if done is not None:
                done(res)
            if complete is not None:
                complete(res)

    def edit_config_cont(res):
        #print('####', tid_state, '(Layer)', name, 'edit_config_cont', err=True)
        if tid_state is not None:
            commit(tid_state, isinstance(res, str) and res == 'Ok', db)
            if done_cont is not None:
                #print('   #', tid_state, '(Layer)', name, 'EDIT_CONFIG DONE', res, err=True)
                done_cont(res)
            if comp_cont is not None:
                wait_complete(comp_cont)
        done_cont = None
        tid_state = None

    def configure(tid, diff_per_source):
        #print('####', tid, '(Layer)', name, 'configure', list(diff_per_source.keys()), err=True)
        buf.update(diff_per_source.items())

    def recompute(done: ?action(value)->None=None, complete: ?action(value)->None=None, force=False):
        tid = 'tr' + actorid()
        #print('####', tid, '(Layer)', name, 'recompute', actorid(), err=True)
        res = apply(tid, force)
        if isinstance(res, str) and res == 'Ok':
            done_cont = done
            comp_cont = complete
            lock(tid, edit_config_cont)                                     # yield await
        else:
            if done is not None:
                done(res)
            if complete is not None:
                complete(res)

        # TODO: Optimize by cull operations unnecessary due to no input diff?

    def apply(tid, force=False):
        #print('####', tid, '(Layer)', name, 'apply', err=True)
        diff = buf
        buf = {}
        #print('   #', tid, '(Layer)', name, 'APPLY\n' + per_src(diff), err=True)
        res = root.configure(tid, diff, lower, force)
        if not isinstance(res, Exception) and lower is not None:
            res = lower.apply(tid, force=False)
        rr = 'Ok' if isinstance(res, str) and res == 'Empty' else res
        #print('   #', tid, '(Layer)', name, 'APPLY RESULT', rr, err=True)
        return rr

    # yield action
    def lock(tid, done:?action(value)->None=None):
        #print('####', tid, '(Layer)', name, 'lock', err=True)
        if buf:                                         # An upper layer has re-configured
            #print('####', tid, '(Layer)', name, 'LOCK RE-APPLY', err=True)
            res = apply(tid, force=False)
            if isinstance(res, Exception):
                if done is not None:
                    done(res)
                return
        tid_state = tid
        lock_cont = done
        root.lock(tid, lower, lock_cont1)                                   # yield await

    def lock_cont1(res):
        #print('####', tid_state, '(Layer)', name, 'lock_cont1', err=True)
        if tid_state is not None:
            if not isinstance(res, Exception) and lower is not None:
                #print('   #', tid_state, '(Layer)', name, 'LOCK LOWER', err=True)
                lower.lock(tid_state, lock_cont2)                           # yield await
            else:
                lock_cont2(res)

    def lock_cont2(res):
        #print('####', tid_state, '(Layer)', name, 'lock_cont2', err=True)
        if lock_cont is not None:
            rr = 'Ok' if isinstance(res, str) and res == 'Empty' else res
            #print('   #', tid_state, '(Layer)', name, 'LOCK RESULT', rr, err=True)
            lock_cont(rr)
        lock_cont = None

    def commit(tid, ok, db):
        #print('####', tid, '(Layer)', name, 'commit', ok, err=True)
        await async root.commit(tid, ok, db)
        if lower is not None:
            await async lower.commit(tid, ok, db)

    def wait_complete(done:action(value)->None):
        #print('####', tid_state, '(Layer)', name, 'wait_complete', err=True)
        if tid_state is not None:
            if lower is not None:
                lower.wait_complete(done)
            else:
                root.wait_complete(tid_state, done)

    def get():
        #print('####', '(Layer)', name, 'GET', root, err=True)
        return root.get()

    def below():
        return lower if lower is not None else self


############## Containers ##################

def Container(template={}, ns:?str=None, module:?str=None) -> proc(list[str], ?Layer)->Node:
    return lambda path, lower: Node(_Container(path, template, ns, module, lower))

class _Container(_Node):
    elems: dict[str, Node]
    ns: ?str
    module: ?str

    def __init__(self, path, template: dict[str, proc(list[str], ?Layer)->Node], ns, module, lower: ?Layer):
        self.path = path
        self.elems = {key: templ(path + [key], lower) for key, templ in template.items()}
        self.ns = ns
        self.module = module

    def newtrans(self):
        return ContainerTransaction(self.path, self.elems, self.ns, self.module)

    def get(self):
        #print('####', '(Container)', self.path, actorid(),'NODE GET', err=True)
        res = {tag: node.get() for tag, node in self.elems.items()}
        return gdata.Container(res, ns=self.ns, module=self.module)


def ContainerTransaction(path, contents, ns:?str=None, module:?str=None):
    return Transaction(_ContainerTransaction(path, contents, ns, module))

class _ContainerTransaction(_Transaction):
    elems : dict[str, Transaction]
    accum : dict[str, value]
    state : ?YieldState
    ns: ?str
    module: ?str

    def __init__(self, path, contents, ns, module):
        self.path = path
        self.elems = {}
        self.accum = {}
        self.state = None
        self.ns = ns
        self.elems = {key: node.newtrans() for key, node in contents.items()}
        self.module = module

    def configure(self, tid, diff, out, force=False):
        #print('####', tid, '(Container)', self.path, 'configure force:', force, actorid(), err=True)
        diff_by_child = transpose(diff)
        # Extra nodes present in diff_by_child represent configuration that is
        # not any of our embedded transforms. These may be key leaf values, or
        # in general any other configuration nodes in the same list element.
        # In any case this container is not responsible for tracking them, so we remove them.
        for k in set(diff_by_child.keys()) - set(self.elems.keys()) - set([WILDKEY]):
            del diff_by_child[k]

        if len(diff_by_child) == 0 and force:
            for k in self.elems.keys():
                diff_by_child[k] = {}
        elif WILDKEY in diff_by_child:
            wildconf = diff_by_child[WILDKEY]
            for k in self.elems.keys():
                if k in diff_by_child:
                    diff_by_child[k].update(wildconf.items())
                else:
                    diff_by_child[k] = wildconf
            del diff_by_child[WILDKEY]
        msgs = {}
        for child,subdiff in diff_by_child.items():
            if child in self.elems:
                #print('   #', tid, '(Container)', self.path, 'CONFIGURE CHILD', child, err=True)
                msgs[child] = async self.elems[child].configure(tid, subdiff, out, force)
        results = {}
        for child,msg in msgs.items():
            results[child] = await msg
            #print('   #', tid, '(Container)', self.path, 'RESULT CHILD', child, ':', results[child], err=True)
        return self._analyze(results)

    def _analyze(self, results):
        self.accum.update(results.items())
        res = "Empty"
        for r in results.values():
            if isinstance(r, Exception):
                #print('   # ...... (Container)', self.path, 'ANALYZE RESULT:', r, err=True)
                return r
            if isinstance(r, str) and r == "Ok":
                res = r
        #print('   # ...... (Container)', self.path, 'ANALYZE RESULT: Ok', err=True)
        return res

    # yield action
    def lock(self, actself, tid, out: ?Session, done):
        #print('####', tid, '(Container)', self.path, 'lock', sorted(self.accum.keys()), err=True)
        it = iter(sorted(self.accum.keys()))
        try:
            key = next(it)
            self.state = YieldState(it, key, tid, out, done)
            tr = self.elems[key]
            #print('   #', tid, '(Container)', self.path, 'LOCK CHILD', key, err=True)
            tr.lock(tid, out, actself.lock_cont)                    # yield await
        except StopIteration:
            #print('   #', tid, '(Container)', self.path, 'LOCK IMMEDIATELY DONE', err=True)
            done('Ok')

    def lock_cont(self, actself, res):
        state = self.state
        if state is not None:
            #print('   #', state.tid, '(Container)', self.path, 'LOCK CHILD', state.key, 'RESULT:', res, err=True)
            state.results[state.key] = res
            try:
                key = next(state.it)
                state.key = key
                tr = self.elems[key]
                #print('   #', state.tid, '(Container)', self.path, 'LOCK CHILD', key, err=True)
                tr.lock(state.tid, state.out, actself.lock_cont)
            except StopIteration:
                self.state = None
                #print('   #', state.tid, '(Container)', self.path, 'LOCK DONE', err=True)
                state.done(self._analyze(state.results))
        else:
            #print('#### ...... (Container)', self.path, 'lock_cont empty state!!!', err=True)
            pass

    proc def commit(self, tid, ok, db):
        #print('####', tid, '(Container)', self.path, 'commit', ok, err=True)
        msgs = []
        for child in self.accum.keys():
            #print('   #', tid, '(Container)', self.path, 'COMMIT CHILD', child, err=True)
            msgs.append( async self.elems[child].commit(tid, ok, db) )
        for msg in msgs:
            await msg
        #print('   #', tid, '(Container)', self.path, 'COMMIT DONE', err=True)
        self.accum = {}

    # yield action
    def wait_complete(self, actself, tid, done):
        #print('####', tid, '(Container)', self.path, 'wait_complete', list(self.accum.keys()), err=True)
        it = iter(sorted(self.elems.keys()))
        try:
            key = next(it)
            self.state = YieldState(it, key, tid, None, done)
            tr = self.elems[key]
            #print('   #', tid, '(Container)', self.path, 'COMPLETE CHILD', key, err=True)
            tr.wait_complete(tid, actself.wait_complete_cont)               # yield await
        except StopIteration:
            #print('   #', tid, '(Container)', self.path, 'COMPLETION IMMEDIATELY DONE', err=True)
            done('Ok')

    proc def wait_complete_cont (self, actself, res):
        state = self.state
        if state is not None:
            #print('   #', state.tid, '(Container)', self.path, 'COMPLETE CHILD', state.key, 'RESULT:', res, err=True)
            state.results[state.key] = res
            try:
                key = next(state.it)
                state.key = key
                tr = self.elems[key]
                #print('   #', state.tid, '(Container)', self.path, 'COMPLETE CHILD', key, err=True)
                tr.wait_complete(state.tid, actself.wait_complete_cont)
            except StopIteration:
                self.state = None
                #print('   #', state.tid, '(Container)', self.path, 'COMPLETION DONE', err=True)
                state.done(self._analyze(state.results))
        else:
            #print('#### ...... (Container)', self.path, 'wait_complete_cont empty state!!!', err=True)
            pass

    def get(self):
        #print('####', '(Container)', self.path, actorid(), 'GET', err=True)
        res = {tag: node.get() for tag, node in self.elems.items()}
        return gdata.Container(res, ns=self.ns, module=self.module)


################# Lists ####################

def List(template, key_names: list[str], key_types: list[str], ns:?str=None, module:?str=None) -> proc(list[str], ?Layer)->Node:
    return lambda path, lower: Node(_List(path, template, key_names, key_types, ns, module, lower))

class _List(_Node):
    liststate: ListState
    ns: ?str
    module: ?str

    def __init__(self, path, template, key_names, key_types, ns, module, lower: ?Layer):
        self.path = path
        self.key_names = key_names
        self.key_types = key_types
        self.ns = ns
        self.module = module
        self.liststate = ListState(path, template, ns, module, lower)

    def newtrans(self):
        return ListTransaction(self.path, self.liststate, self.key_names, self.key_types, self.ns, self.module)

    def get(self):
        #print('####', '(List)', self.path, 'NODE GET', err=True)
        res = []
        for key,node in self.liststate.all().items():
            r = node.get()
            if isinstance(r, gdata.Container):
                res.append(r)
        return gdata.List(self.key_names, res, ns=self.ns, module=self.module)


actor ListState(path, template: proc(list[str], ?Layer) -> Node, ns: ?str, module: ?str, lower: ?Layer):
    var elems = {}
    var active = {}
    var provisional = set()

    def acquire(tid: str, keys: ?set[str]):
        if keys is not None:
            keys1 = keys
            new = keys - set(elems.keys())
            for k in new:
                elems[k] = template(path+[k], lower)
            provisional |= new
            #print('====', tid, path, 'acquire keys:', keys, 'new:', new, 'provisional:', provisional, actorid(), err=True)
        else:
            keys1 = set(elems.keys())
            #print('====', tid, path, 'acquire all keys:', keys1, actorid(), err=True)
        active[tid] = keys1

        return {k: elems[k] for k in keys1}

    def release(tid: str, ok: bool, deletes: set[str]):
        #print('====', tid, path, 'release', ok, 'deletes:', deletes, 'provisional:', provisional, err=True)
        if ok:
            provisional -= active[tid]
            provisional |= deletes
        del active[tid]
        if not active:
            #print('====', tid, path, 'deleting:', provisional, err=True)
            for k in provisional:
                del elems[k]
            provisional = set()

    def all():
        #print('====', 'all:', elems.keys(), 'provosional:', provisional, "active:", active)
        if provisional:
            return {k: elems[k] for k in elems if k not in provisional}
        else:
            return dict(elems.items())


class _ListTransaction(_Transaction):
    liststate : ListState
    key_names : list[str]
    key_types : list[str]
    elems : dict[str, Transaction]
    accum : dict[str, value]
    state : ?YieldState
    reset: bool
    ns: ?str
    module: ?str

    def __init__(self, path, liststate, key_names, key_types, ns, module):
        self.path = path
        self.liststate = liststate
        self.key_names = key_names
        self.key_types = key_types
        self.ns = ns
        self.module = module
        self.elems = {}
        self.accum = {}
        self.state = None
        self.reset = False

    def configure(self, tid, diff, out: ?Session, force=False):
        #print('####', tid, '(List)', self.path, 'configure', actorid(), err=True)
        if self.reset:
            self.elems = {}
            self.accum = {}
            self.reset = False
        diff_by_key = transpose(diff)
        if len(diff_by_key) == 0 and force:
            for key,node in self.liststate.acquire(tid, None).items():
                diff_by_key[key] = {}
                self.elems[key] = node.newtrans()
        elif WILDKEY in diff_by_key:
            wildconf = diff_by_key[WILDKEY]
            for key,node in self.liststate.acquire(tid, None).items():
                if key in diff_by_key:
                    diff_by_key[key].update(wildconf.items())
                else:
                    diff_by_key[key] = wildconf
                self.elems[key] = node.newtrans()
            del diff_by_key[WILDKEY]
        else:
            for key,node in self.liststate.acquire(tid, set(diff_by_key.keys())).items():
                self.elems[key] = node.newtrans()
        msgs = {}
        for key,subdiff in diff_by_key.items():
            #print('   #', tid, '(List)', self.path, 'CONFIGURE ELEMENT', key, err=True)
            msgs[key] = async self.elems[key].configure(tid, subdiff, out, force)
        for key in self.accum.keys():
            if key not in diff_by_key:
                msgs[key] = async self.elems[key].configure(tid, {}, out, force)
        results = {}
        for key,msg in msgs.items():
            results[key] = await msg
            v = results[key]
            #print('   #', tid, '(List)', self.path, 'RESULT ELEMENT', key, ':', v, err=True)
        return self._analyze(results)

    def _analyze(self, results: dict[str,value]):
        self.accum.update(results.items())
        res = 'Empty'
        for r in results.values():
            if isinstance(r, Exception):
                #print('   # ...... (List)', self.path, 'ANALYZE RESULT:', r, err=True)
                return r
            if isinstance(r, str) and r == 'Ok':
                res = r
        #print('   # ...... (List)', self.path, 'ANALYZE RESULT:', res, err=True)
        return res

    # yield action
    def lock(self, actself, tid, out: ?Session, done):
        #print('####', tid, '(List)', self.path, 'lock', sorted(self.accum.keys()), err=True)
        it = iter(sorted(self.accum.keys()))
        try:
            key = next(it)
            self.state = YieldState(it, key, tid, out, done)
            tr = self.elems[key]
            #print('   #', tid, '(List)', self.path, 'LOCK ELEMENT', key, err=True)
            tr.lock(tid, out, actself.lock_cont)                        # yield await
        except StopIteration:
            #print('   #', tid, '(List)', self.path, 'LOCK IMMEDIATELY DONE', err=True)
            done('Ok')

    def lock_cont(self, actself, res):
        state = self.state
        if state is not None:
            #print('   #', state.tid, '(List)', self.path, 'LOCK ELEMENT RESULT:', res, err=True)
            state.results[state.key] = res
            try:
                key = next(state.it)
                state.key = key
                tr = self.elems[key]
                #print('   #', state.tid, '(List)', self.path, 'LOCK ELEMENT', key, err=True)
                tr.lock(state.tid, state.out, actself.lock_cont)
            except StopIteration:
                self.state = None
                #print('   #', state.tid, '(List)', self.path, 'LOCK DONE', err=True)
                state.done(self._analyze(state.results))
        else:
            pass
            #print('#### ...... (List)', self.path, 'lock_cont empty state!!!', err=True)

    def commit(self, tid, ok, db):
        #print('####', tid, '(List)', self.path, 'commit', ok, err=True)
        msgs = []
        for key,tr in self.elems.items():
            #print('   #', tid, '(List)', self.path, 'COMMIT ELEMENT', key, err=True)
            msgs.append( async tr.commit(tid, ok, db) )
        for msg in msgs:
            await msg
        deletes = set()
        for key,res in self.accum.items():
            if isinstance(res, str) and res == 'Empty':
                #print('   #', tid, '(List)', self.path, 'DELETE ELEMENT', key, err=True)
                deletes.add(key)
        self.liststate.release(tid, ok, deletes)
        self.reset = True       # Defer resetting accum, for the benefit of 'wait_complete'

    # yield action
    def wait_complete(self, actself, tid, done):
        #print('####', tid, '(List)', self.path, 'wait_complete', list(self.accum.keys()), err=True)
        it = iter(sorted(self.accum.keys()))
        try:
            key = next(it)
            self.state = YieldState(it, key, tid, None, done)
            tr = self.elems[key]
            #print('   #', tid, '(List)', self.path, 'COMPLETE ELEMENT', key, err=True)
            tr.wait_complete(tid, actself.wait_complete_cont)                   # yield await
        except StopIteration:
            #print('   #', tid, '(List)', self.path, 'COMPLETION IMMEDIATELY DONE', err=True)
            done('Ok')

    def wait_complete_cont (self, actself, res):
        state = self.state
        if state is not None:
            #print('   #', state.tid, '(List)', self.path, 'COMPLETE ELEMENT', state.key, 'RESULT:', res, err=True)
            state.results[state.key] = res
            try:
                key = next(state.it)
                state.key = key
                tr = self.elems[key]
                #print('   #', state.tid, '(List)', self.path, 'COMPLETE ELEMENT', key, err=True)
                tr.wait_complete(state.tid, actself.wait_complete_cont)
            except StopIteration:
                self.state = None
                #print('   #', state.tid, '(List)', self.path, 'COMPLETION DONE', err=True)
                state.done(self._analyze(state.results))
        else:
            pass
            #print('#### ...... (List)', self.path, 'wait_complete_cont empty state!!!', err=True)

    def get(self):
        #print('####', '(List)', self.path, 'GET', err=True)
        res = []
        for key,node in self.liststate.all().items():
            if key in self.elems:
                r = self.elems[key].get()
            else:
                r = node.get()
            if isinstance(r, gdata.Container):
                # Restore the list element key leaf leaf children to keep the
                # gdata valid. This is only necessary when the elements of this
                # list are not any of the ttt.Transform, but ttt.Container.
                #print('####', '(List)', self.path, 'RESTORING KEY', key, err=True)
                split_key = split_key_str(key)
                for i, kn in enumerate(self.key_names):
                    r.children.setdefault(kn, gdata.Leaf(self.key_types[i], split_key[i]))
            res.append(r)
        return gdata.List(self.key_names, res, ns=self.ns, module=self.module)

def ListTransaction(path, liststate: ListState, key_names, key_types, ns, module):
    return Transaction(_ListTransaction(path, liststate, key_names, key_types, ns, module))


################# Transform #####################

class _TransformBase(_Node):
    transaction: Transaction

    def newtrans(self):
        return self.transaction

    def get(self):
        return self.transaction.get()


class _TransformTransactionBase(_Transaction):
    diffs: dict[str, dict[str, gdata.Node]]
    candidates: dict[str, dict[str, gdata.Node]]
    essays: dict[str, (?gdata.Node, ?gdata.Node)]
    running: dict[str, gdata.Node]
    output: ?gdata.Node
    locker: ?str
    pending: list[(Transaction, str, ?Session, action(value)->None)]
    me: str

    compute : proc(tid: str, merged: gdata.Node, out: ?Session) -> (gdata.Node, ?gdata.Node)
    clear : proc(tid: str, out: ?Session) -> None
    finalize : proc(tid: str) -> None

    def __init__(self, path):
        self.diffs = {}
        self.candidates = {}
        self.essays = {}
        self.path = path
        self.running = {}
        self.output = None
        self.locker = None
        self.pending = []
        self.me = ''  # Initialize first before any self reference
        self.me = '(src_' + str(self)[-10:-1] + ')'  # Now safe to use str(self)

    def configure(self, tid, diff, out: ?Session, force=False):
        #print('####', tid, '(Transform)', self.path, 'configure', actorid(), self.me, err=True)

        if tid not in self.diffs:
            self.diffs[tid] = {}
        accdiff = self.diffs[tid]
        accdiff.update(diff.items())
        newconf = patch(self.running, accdiff)
        self.candidates[tid] = newconf

        #print('   #', tid, '(Transform)', self.path, 'NEW DIFF\n' + per_src(diff), err=True)
        #print('   #', tid, '(Transform)', self.path, 'ACCUMULATED DIFF\n' + per_src(accdiff), err=True)
        #print('   #', tid, '(Transform)', self.path, 'RUNNING CONFIG\n' + per_src(self.running), err=True)
        #print('   #', tid, '(Transform)', self.path, 'NEWCONF\n' + per_src(newconf), err=True)

        if newconf == {}:
            self.essays[tid] = (None, None) # TODO: do we want to keep memory?
            #print('   #', tid, '(Transform)', self.path, 'EMPTY CONFIG', err=True)
            self.clear(tid, out)
            return 'Empty'
        else:
            try:
                merged = assert_complete(merge(newconf))
                #print('   #', tid, '(Transform)', self.path, 'MERGED\n       ', merged.prsrc(indent=4), err=True)
#                assert self.validate(merged)
            except Exception as e:
                #print('   #', tid, '(Transform)', self.path, 'FAILURE', e, err=True)
                return e
            else:
                newout, newmem = self.compute(tid, merged, out)
                self.essays[tid] = (newout, newmem)
                #print('   #', tid, '(Transform)', self.path, 'OUTPUT\n       ', newout.prsrc(indent=4), err=True)
                return 'Ok'
        return 'Ok'

    # yield action
    def lock(self, actself, tid, out: ?Session, done):                          # yield await
        #print('####', tid, '(Transform)', self.path, 'lock', err=True)
        locker = self.locker
        if locker is not None:
            if locker == tid:
                #print('   #', tid, '(Transform)', self.path, 'LOCK REDUNDANT', err=True)
                done('Ok')
            else:
                #print('   #', tid, '(Transform)', self.path, 'LOCK SUSPENDING', err=True)
                self.pending.append((actself, tid, out, done))                  # suspend
            return
        self.locker = tid
        if tid not in self.candidates:
            #print('   #', tid, '(Transform)', self.path, 'LOCK - RE-CONFIGURING', err=True)
            res = self.configure(tid, {}, out)
            done(res)
        else:
            #print('   #', tid, '(Transform)', self.path, 'LOCKED', err=True)
            done('Ok' if self.candidates[tid] else 'Empty')

    def lock_cont (self, actself, res):
        pass

    def commit(self, tid, ok, db):
        #print('####', tid, '(Transform)', self.path, 'commit', ok, err=True)
        self.diffs.pop(tid)
        candidate = self.candidates.pop_def(tid, {})
        essay = self.essays.pop(tid)
        if tid == self.locker:
            if ok:
                self.running = candidate
                self.output = essay.0 if essay is not None else None
                self.update_memory(essay.1 if essay is not None else None)
                #print('   #', tid, '(Transform)', self.path, 'COMMITTING\n' + per_src(candidate), err=True)
                if self.candidates:
                    #print('   #', tid, '(Transform)', self.path, 'INVALIDATING', set(self.candidates.keys()), err=True)
                    self.candidates = {}
                self.finalize(tid)
            else:
                #print('   #', tid, '(Transform)', self.path, 'ABORTING', err=True)
                pass
            self.locker = None
            if self.pending:
                (actself, tid2, out, done) = self.pending.pop(0)
                #print('   #', tid2, '(Transform)', self.path, 'RESUMING', err=True)
                self.lock(actself, tid2, out, done)                             # resume
        else:
            #print('   #', tid, '(Transform)', self.path, 'IGNORING', err=True)
            pass

    mut def update_memory(self, newmem: ?gdata.Node):
        pass

    def finalize(self, tid):
        pass

    def wait_complete(self, actself, tid, done):                                # (yield await)
        #print('####', tid, '(Transform)', self.path, 'wait_complete', err=True)
        done('Ok')

    def wait_complete_cont (self, actself, res):
        pass

    def get(self):
        if self.running:
            return merge(self.running)
        else:
            return gdata.Container()


class TransformActorParams:
    def __init__(self, update_dynstate: proc(?yang.adata.MNode) -> None, dev: ?odev.DeviceMgr):
        self.update_dynstate = update_dynstate
        self.dev = dev


def Transform(function, act: ?(proc(TransformActorParams) -> ?proc(gdata.Node, ?gdata.Node) -> None)=None, lower: ?Layer=None, log_handler: ?logging.Handler=None) -> proc(list[str], ?Layer)->Node:
    proc def _create_transform_node(path, lower):
        transform = _Transform(path, function, lower, log_handler)
        node = Node(transform)
        if act is not None:
            transform.init_dynstate(node, act)
        return node
    return _create_transform_node

class _Transform(_TransformBase):
    def __init__(self, path, function, lower, log_handler):
        self.path = path
        self.transaction = TransformTransaction(path, function, lower, log_handler)

    proc def init_dynstate(self, node, act: proc(TransformActorParams) -> ?proc(gdata.Node, ?gdata.Node) -> None):
        self.transaction.init_dynstate(node, act)

def TransformTransaction(path, function, lower, log_handler):
    return Transaction(_TransformTransaction(path, function, lower, log_handler))

class _TransformTransaction(_TransformTransactionBase):
    function: TransformFunction
    memory: ?gdata.Node
    dynstate: ?gdata.Node
    node: ?Node
    lower: ?Layer

    def __init__(self, path, function: proc(?logging.Handler) -> TransformFunction, lower: ?Layer, log_handler):
        self.memory = None
        self.dynstate = None
        self.node = None
        _TransformTransactionBase.__init__(self, path)
        self.function = function(log_handler)
        self.lower = lower

    def compute(self, tid, merged, out):
        newoutmem = self.function.transform_wrapper(merged, self.memory, self.dynstate)
        newout = newoutmem.0
        res = difference(self.output, newout)
        if out is not None and res is not None:
            out.configure(tid, {self.me: res})
        return newoutmem

    def clear(self, tid, out):
        output = self.output
        if output is not None:
            #print('   #', tid, '(Transform)', self.path, 'CLEARING ' + output.prsrc(), err=True)
            res = difference(self.output, gdata.Container())
            if out is not None and res is not None:
                out.configure(tid, {self.me: res})

    def update_memory(self, newmem):
        self.memory = newmem

    proc def init_dynstate(self, node, act: proc(TransformActorParams) -> ?proc(gdata.Node, ?gdata.Node) -> None, update_dynstate):
        self.node = node
        self.function.init_dynstate(act, update_dynstate)

    proc def update_dynstate(self, dynstate):
        self.dynstate = dynstate
        _node = self.node
        if _node is not None:
            Session(self.me, _node, self.lower).recompute() # TODO: Verify that this always succeeds (due to no input diff)?

    def finalize(self, tid):
        #print('####', tid, '(_TransformTransaction)', self.path, 'finalize', actorid(), err=True)
        # Run transform.on_conf only When we have an updated running config
        if self.running:
            self.function.on_conf(self.get(), self.memory)

class TransformFunction(object):
    transform_wrapper: mut(gdata.Node, ?gdata.Node, ?gdata.Node) -> (gdata.Node, ?gdata.Node)
    transform_xml: mut(xml.Node, ?gdata.Node, ?gdata.Node) -> (gdata.Node, ?gdata.Node)
    _on_conf: ?proc(gdata.Node, ?gdata.Node) -> None
    logger: logging.Logger

    def __init__(self, log_handler: ?logging.Handler=None):
        self._on_conf = None
        self.logger = logging.Logger(log_handler)

    def transform_wrapper(self, cfg, memory, dynstate):
        return (gdata.Container(), None)

    def transform_xml(self, cfg, memory, dynstate):
        return gdata.Container(), None

    proc def init_dynstate(self, act: proc(TransformActorParams) -> ?proc(gdata.Node, ?gdata.Node) -> None, update_dynstate: proc(?yang.adata.MNode)->None):
        self._on_conf = act(TransformActorParams(update_dynstate, None))

    proc def on_conf(self, conf: gdata.Node, memory: ?gdata.Node):
        _on_conf = self._on_conf
        if _on_conf is not None:
            _on_conf(conf, memory)

################# RFSTransform ###################

def RFSTransform(function, dev_registry: odev.DeviceRegistry, act: ?(proc(TransformActorParams) -> ?proc(gdata.Node, ?gdata.Node) -> None)=None, lower: ?Layer=None, log_handler: ?logging.Handler=None) -> proc(list[str], ?Layer)->Node:
    proc def _create_rfs_transform_node(path, lower):
        rfs_transform = _RFSTransform(path, function, dev_registry, lower, log_handler)
        node = Node(rfs_transform)
        if act is not None:
            rfs_transform.init_dynstate(node, act)
        return node
    return _create_rfs_transform_node


class _RFSTransform(_TransformBase):
    def __init__(self, path, function, dev_registry, lower, log_handler):
        self.path = path
        self.transaction = RFSTransaction(path, function, dev_registry, lower, log_handler)

    proc def init_dynstate(self, node, act: proc(TransformActorParams) -> ?proc(gdata.Node, ?gdata.Node) -> None):
        self.transaction.init_dynstate(node, act)

def RFSTransaction(path, function, dev_registry, lower, log_handler):
    return Transaction(_RFSTransaction(path, function, dev_registry, lower, log_handler))

class _RFSTransaction(_TransformTransactionBase):
    function: RFSFunction
    devname: str
    dev: odev.DeviceMgr
    memory: ?gdata.Node
    dynstate: ?gdata.Node
    node: ?Node
    lower: ?Layer

    def __init__(self, path, function: proc(?logging.Handler) -> RFSFunction, dev_registry: odev.DeviceRegistry, lower: ?Layer, log_handler):
        self.memory = None
        self.dynstate = None
        self.node = None
        self.devname = ""  # Initialize before parent init
        _TransformTransactionBase.__init__(self, path)
        self.function = function(log_handler)
        if len(path) < 3:
            raise ValueError(f"RFSTransform {path}: path length < 3")
        self.devname = path[-3]
        self.dev = dev_registry.get(self.devname)
        self.lower = lower

    def compute(self, tid, merged, out):
        #print('####', tid, '(RFSTransform)', self.path, 'compute', actorid(), err=True)
        dev_content = {
            "name": gdata.Leaf("string", self.devname),
        }
        modset, modset_id = self.dev.get_modules()
        if modset_id is not None:
            dev_content["modset_id"] = gdata.Leaf("string", modset_id)
        if len(modset) > 0:
            #print('####', tid, '(RFSTransform)', self.path, 'compute', self.devname, err=True)
            newoutmem = self.function.transform_wrapper(merged, DeviceInfo(self.devname, modset), self.memory, self.dynstate)
            newout = newoutmem.0
            res = difference(self.output, newout)
            if isinstance(res, gdata.Container):
                dev_content["config"] = res
        else:
            #print('####', tid, '(RFSTransform)', self.path, 'compute', ": No device capabilities, skipping RFS transform for", self.devname, err=True)
            newoutmem = (gdata.Container({}), None)

        if out is not None:
            embedded_res = self.embed(dev_content)
            out.configure(tid, {self.me: embedded_res})
        return newoutmem # TODO: dynstate for RFS?

    def clear(self, tid, out):
        output = self.output
        if out is not None and output is not None:
            diff = difference(output, gdata.Container())
            if isinstance(diff, gdata.Container):
                dev_content = {
                    "name": gdata.Leaf("str", self.devname),
                    "config": diff
                }
                embedded_diff: gdata.Node = self.embed(dev_content)
                out.configure(tid, {self.me: embedded_diff})

    def embed(self, dev_content):
        return gdata.Container({
            "devices": gdata.Container({
                "device": gdata.List(["name"], [
                    gdata.Container(dev_content)
                ])
            })
        }, ns="http://orchestron.org/yang/orchestron-device.yang", module="orchestron-device")

    def update_memory(self, newmem):
        self.memory = newmem

    proc def init_dynstate(self, node, act: proc(TransformActorParams) -> ?proc(gdata.Node, ?gdata.Node) -> None, update_dynstate):
        self.node = node
        self.function.init_dynstate(act, update_dynstate, self.dev)

    proc def update_dynstate(self, dynstate):
        self.dynstate = dynstate
        _node = self.node
        if _node is not None:
            Session(self.me, _node, self.lower).recompute() # TODO: Verify that this always succeeds (due to no input diff)?

    def finalize(self, tid):
        #print('####', tid, '(_TransformTransaction)', self.path, 'finalize', actorid(), err=True)
        # Run transform.on_conf only When we have an updated running config and there is actual output (i.e. the transform function was run)
        if self.running:
            output = self.output
            if output is not None:
                if not (isinstance(output, gdata.Container) and not output.presence and len(output.children) == 0):
                    self.function.on_conf(self.get(), self.memory)

class DeviceInfo(object):
    name: str
    modules: dict[str, odev.ModCap]

    def __init__(self, name: str, modules: dict[str, odev.ModCap] = {}):
        self.name = name
        self.modules = modules

class RFSFunction(object):
    transform_wrapper: mut(gdata.Node, DeviceInfo, ?gdata.Node, ?gdata.Node) -> (gdata.Node, ?gdata.Node)
    transform_xml: mut(xml.Node, DeviceInfo, ?gdata.Node, ?gdata.Node) -> (gdata.Node, ?gdata.Node)
    _on_conf: ?proc(gdata.Node, ?gdata.Node) -> None
    logger: logging.Logger

    def __init__(self, log_handler: ?logging.Handler=None):
        self._on_conf = None
        self.logger = logging.Logger(log_handler)

    def transform_wrapper(self, cfg, di, memory, dynstate):
        return (gdata.Container(), None)

    def transform_xml(self, cfg, di, memory, dynstate):
        return (gdata.Container(), None)

    proc def init_dynstate(self, act: proc(TransformActorParams) -> ?proc(gdata.Node, ?gdata.Node) -> None, update_dynstate: proc(?yang.adata.MNode)->None, dev: odev.DeviceMgr):
        self._on_conf = act(TransformActorParams(update_dynstate, dev))

    proc def on_conf(self, conf: gdata.Node, memory: ?gdata.Node):
        _on_conf = self._on_conf
        if _on_conf is not None:
            _on_conf(conf, memory)


################# Device #####################

def Device(dev_registry: odev.DeviceRegistry, log_handler: ?logging.Handler=None) -> proc(list[str], ?Layer)->Node:
    return lambda path, _lower: Node(_Device(path, dev_registry, log_handler))

class _Device(_TransformBase):
    def __init__(self, path, dev_registry, log_handler):
        self.path = path
        self.transaction = DeviceTransaction(path, dev_registry, log_handler)

def DeviceTransaction(path, dev_registry, log_handler):
    return Transaction(_DeviceTransaction(path, dev_registry, log_handler))

class _DeviceTransaction(_TransformTransactionBase):
    dev: odev.DeviceMgr
    logger: logging.Logger

    def __init__(self, path, dev_registry: odev.DeviceRegistry, log_handler):
        _TransformTransactionBase.__init__(self, path)
        self.dev = dev_registry.get(path[-1])
        self.logger = logging.Logger(log_handler)

    def compute(self, tid, merged, out):
        return merged, None

    def clear(self, tid, out):
        pass

    def finalize(self, tid):
        #print('####', tid, '(DeviceMeta)', self.path, 'finalize', actorid(), err=True)
        config = self.output
        if config is not None:
            meta_config = DeviceMetaConfig.from_gdata(config)
            self.dev.set_dmc(meta_config)


################# DeviceConfig #####################

def DeviceConfig(dev_registry: odev.DeviceRegistry, log_handler: ?logging.Handler=None) -> proc(list[str], ?Layer)->Node:
    return lambda path, _lower: Node(_DeviceConfig(path, dev_registry, log_handler))

class _DeviceConfig(_TransformBase):
    def __init__(self, path, dev_registry, log_handler):
        self.path = path
        self.transaction = DeviceConfigTransaction(path, dev_registry, log_handler)

def DeviceConfigTransaction(path, dev_registry, log_handler):
    return Transaction(_DeviceConfigTransaction(path, dev_registry, log_handler))

class _DeviceConfigTransaction(_TransformTransactionBase):
    dev: odev.DeviceMgr
    logger: logging.Logger

    def __init__(self, path, dev_registry: odev.DeviceRegistry, log_handler):
        _TransformTransactionBase.__init__(self, path)
        self.dev = dev_registry.get(path[-1])
        self.logger = logging.Logger(log_handler)

    def compute(self, tid, merged, out):
        return merged, None

    def clear(self, tid, out):
        pass

    def finalize(self, tid):
        #print('####', tid, '(DeviceConfig)', self.path, 'finalize', actorid(), err=True)
        device = self.output
        if device is not None:
            if isinstance(device, gdata.Container):
                if "config" in device.children:
                    config = device.children["config"]
                    cfg_modset_id = None
                    modset_id_leaf = device.children.get("modset_id")
                    if isinstance(modset_id_leaf, gdata.Leaf):
                        modset_id_val = modset_id_leaf.val
                        if isinstance(modset_id_val, str):
                            cfg_modset_id = modset_id_val
                    if isinstance(config, gdata.Container):
                        cfg = gdata.Container(config.children)
                        self.dev.configure(cfg, cfg_modset_id, tid)
                else:
                    #print('   #', tid, '(DeviceConfig)', self.path, "No config in device config, registering interest...", err=True)
                    self.dev.configure(None, None, tid)


    def wait_complete(self, actself, tid, done):                                # (yield await)
        #print('####', tid, '(DeviceConfig)', self.path, 'wait_complete', err=True)
        self.dev.wait_complete(tid, done)


################# Trivials #####################

class PassThrough(TransformFunction):
    def transform_wrapper(self, cfg, memory, dynstate):
        return (cfg, memory)

def Sink():
    return Layer('sink', Transform(PassThrough), None, None)
